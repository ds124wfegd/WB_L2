package main

import "fmt"

func test() (x int) { // Именованный возвращаемый параметр, здесь x = 0
	defer func() {
		x++
	}()
	x = 1
	return // возврат x = 2

	/*
		1) x = 1 — присваивание значения

		2) return — начинается процесс возврата значения (текущее значение x = 1)

		3) Выполняется defer функция: x++ увеличивает x до 2

		функция возвращает значение x (которое теперь равно 2)
	*/
}

func anotherTest() int { //Неименованный возвращаемый параметр
	var x int // x = 0
	defer func() {
		x++ // x = 1 + 1 = 2
	}()
	x = 1
	return x // возврат x =1

	/*
	   1) x = 1 — присваивание значения

	   2) return x — значение x (равное 1) копируется в возвращаемый результат

	   3) Выполняется defer функция: x++ увеличивает локальную переменную x до 2, но это не влияет на уже скопированное возвращаемое значение

	   функция возвращает значение, которое было скопировано на шаге 2 (т.е. 1)
	*/
}

func main() {
	fmt.Println(test())        //вызов функции test()
	fmt.Println(anotherTest()) //вызов функции anotherTest()
}

/*
defer выполняются в обратном порядке, следования в функции. Т.к. функция содержит 1 defer то вывод будет в порядке следования функций:
2
1

defer выполняется после того, как значение для возврата уже подготовлено (скопировано), но до самого возврата из функции.
Это объясняет разницу в поведении для именованных и неименованных возвращаемых параметров.
*/
